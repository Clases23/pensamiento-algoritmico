# Banco de Ejercicios Integradores – Repaso Final
**Incluyen simultáneamente:** condicionales, ciclos (`for` / `while`), **ciclos anidados** y **funciones** (con/sin parámetros y con/sin retorno).  
**Sugerencias generales:**  
- Si usas pseudocódigo, emplea **“=”** para asignación.   
- Valida entradas y usa menús cuando aplique.

---

## 1) Gestor de Calificaciones con Reportes
**Objetivo:** funciones + `while True` + condicionales + anidados para reportes.  
**Descripción:** Implementa un programa que permita registrar notas de varios estudiantes y generar informes.
- **Funciones sugeridas:**
  - `leer_nota()` → sin parámetros, retorna `float` en `0..5` (reintenta si es inválida).
  - `agregar_estudiante(nombre)` → con parámetro, sin retorno: pide `k` notas y guarda promedio.
  - `reporte_resumen()` → sin parámetros, sin retorno: imprime total de estudiantes, mejor promedio, peor promedio y promedio global.
- **Flujo:** menú: `A) Agregar`, `R) Reporte`, `X) Salir`.  
- **Requisitos de lógica:**
  - Usa **ciclos anidados** al registrar notas: un ciclo para estudiantes (externo por menú) y uno interno para notas.
  - Condicionales para clasificar promedios: `<3.0` (reprobado), `3.0..3.9` (regular), `≥4.0` (destacado).
- **Casos de prueba (I/O):**  
  - Agrega 2 estudiantes con 3 notas cada uno, genera reporte, verifica mejor/peor y promedio global.

---

## 2) Tienda Minimal con Caja y Descuentos Escalonados
**Objetivo:** funciones con parámetros/retorno + bucles + condicionales.  
**Descripción:** Simula ventas hasta que el cajero elija salir.
- **Funciones sugeridas:**
  - `calcular_descuento(subtotal)` → retorna % según escalas: `<100000:0%`, `100000–299999:5%`, `300000–499999:8%`, `≥500000:10%`.
  - `procesar_compra()` → sin parámetros: en un `while`, lee pares `precio, cantidad` hasta `0,0`; calcula subtotal, descuento, total.
- **Menú principal:** `N) Nueva compra`, `R) Resumen del día`, `X) Salir`.
- **Resumen del día (ciclos anidados):** total de ventas, ticket promedio, ticket máximo.
- **Validaciones:** precios y cantidades > 0 (salvo `0,0` centinela para terminar compra).

---

## 3) Biblioteca de Utilidades Numéricas (Módulo)
**Objetivo:** diseñar funciones “puras” y combinarlas.  
**Implementa:**
- `es_primo(n)` → retorna `True/False` probando divisores `2..n-1` (usa `while`).
- `contar_primos_en_rango(a, b)` → retorna cuántos primos hay (usa `for` y llama a `es_primo`).
- `descomponer_en_factores(n)` → **sin listas**, imprime factores en orden creciente usando `while` y divisiones sucesivas.
- **Programa principal:** menú para elegir operación, validar entradas y repetir hasta salir.
- **Ciclos anidados:** en `contar_primos_en_rango` (rango externo) + prueba de primalidad (interno).

---

## 4) Pintor de Patrones (ASCII)
**Objetivo:** anidados + funciones de dibujo con parámetros.  
**Patrones a implementar (cada uno función separada):**
- `rectangulo_hueco(f, c, ch)` → bordes con `ch`.
- `triangulo_derecha(h, ch)` → fila `k` imprime `k` caracteres.
- `piramide_centrada(h, ch)` → fila `k` imprime espacios y `2k-1` `ch`.  
**Menú:** elegir figura y tamaño; repetir hasta salir.  
**Validaciones:** tamaños ≥ 1; `ch` un solo carácter.

---

## 5) Analizador de Texto (sin métodos avanzados)
**Objetivo:** funciones + ciclos + condicionales y contadores manuales.
- **Restricción:** no usar `len`, `count`, `split`, `lower/upper`, etc. (haz conteo manual).
- **Funciones:**
  - `longitud(cadena)` → cuenta caracteres con `for`.
  - `contar_vocales_minus(cadena)` → recorre y compara con `a,e,i,o,u`.
  - `contar_palabras(cadena)` → estado `en_palabra`; incrementa al pasar de espacio→letra.
  - `buscar_patron(texto, patron)` → **búsqueda ingenua** con dos bucles (superposiciones permitidas).
- **Menú:** ingresar texto y ejecutar operaciones; repetir.

---

## 6) Matriz “en streaming” (sin almacenar toda la matriz)
**Objetivo:** anidados + cálculos por posición.  
**Descripción:** Para una matriz `N×N` de valores leídos **uno por uno**, imprime:
- Suma diagonal principal, diagonal secundaria, suma de fila `r`, suma de columna `c`.
- **Funciones:**
  - `acumular_posicion(i, j, x, estado)` → con parámetros, sin retorno: actualiza acumuladores (usa `estado` como estructura mínima: variables globales o tuplas retornadas si prefieres mantener pureza).
  - `mostrar_reporte()` → imprime resultados al final.
- **Flujo:** doble bucle `for` sobre `i,j`; por cada lectura `x`, actualiza según reglas (`i==j`, `i+j==N-1`, `i==r`, `j==c`).

---

## 7) Juego “Adivina el Número” con Pistas y Estadísticas
**Objetivo:** `while True` + funciones + condicionales.
- **Funciones:**
  - `jugar_una_ronda(lim_sup)` → el programa **elige** un número secreto (puede ser leído manualmente por el profesor durante pruebas). En un `while`, el usuario intenta: mostrar `alto/bajo/correcto`, contar intentos.
  - `actualizar_estadisticas(intentos)` → lleva total de rondas, intentos totales, mejor (mínimo) y peor (máximo) intento.
  - `mostrar_estadisticas()` → imprime resumen.
- **Menú:** `J) Jugar`, `E) Estadísticas`, `X) Salir`.  
- **Validaciones:** entrada numérica, límites positivos.

---

## 8) Simulador de Ahorro con Metas
**Objetivo:** funciones con retorno + `while` + condicionales.
- **Funciones:**
  - `meses_hasta_meta(meta, mensual, interes)` → retorna número de meses para alcanzar o superar la meta; crecimiento mensual: `saldo = (saldo + mensual) * (1 + interes)`.
  - `escenario_interactivo()` → pide meta/mensual/interés y muestra meses; permite comparar **dos escenarios** y decir cuál es más rápido.
- **Validaciones:** valores > 0; `interes` como decimal (ej. 0.01 para 1% mensual).

---

## 9) Procesador de Secuencias con Filtros
**Objetivo:** anidados + funciones “puras”.
- **Entrada:** cantidad `K` y luego `K` números (uno por lectura).
- **Funciones:**
  - `es_par(n)`, `es_multiplo(n, k)`, `clasificar(n)` → retorna texto según reglas (ej.: “par y >100”, etc.).
  - `resumen(K)` → en un ciclo lee `K` números, usa las funciones y computa: suma de pares, conteo de múltiplos de 3, mínimo y máximo (con bandera “primer dato”), promedio general.
- **Salida:** imprimir resumen y la clasificación del **último** número procesado (o todos, a elección del profe).

---

## 10) Mini–Cajero con Funciones y Validaciones
**Objetivo:** `while True` + condicionales + funciones con/sin retorno.
- **Funciones:**
  - `depositar(saldo, monto)` → retorna nuevo saldo (si `monto>0`).
  - `retirar(saldo, monto)` → retorna nuevo saldo si hay fondos; si no, retorna el mismo saldo y un código de error (define protocolo).
  - `consultar(saldo)` → imprime saldo.
- **Menú:** `D) Depósito`, `R) Retiro`, `C) Consulta`, `X) Salir`.
- **Reglas:** no permitir saldo negativo; manejar montos no válidos.

---

## 11) Reporte de Temperaturas (mín, máx, promedio) con Segmentos
**Objetivo:** anidados + agregaciones por tramo.
- **Entrada:** número de días `D`; por cada día, número de mediciones `M` y luego `M` temperaturas.
- **Funciones:**
  - `procesar_dia(M)` → retorna (mín, máx, promedio del día).
  - `actualizar_global(min_d, max_d, prom_d)` → acumula para resumen global.
- **Salida:** por día, sus tres métricas; al final, mínimo global, máximo global y promedio global.
- **Ciclos anidados:** días (externo) y mediciones (interno).

---

## 12) Evaluador de Expresiones Aritméticas Simples
**Objetivo:** condicionales + ciclos + funciones puras.
- **Restricción didáctica:** solo operadores `+`, `-`, `*`, `/` entre **dos** operandos (no usar `eval`).  
- **Funciones:**
  - `es_numero(s)` → retorna `True/False` (validación básica).
  - `evaluar(a, op, b)` → retorna resultado, maneja `/` por cero.
  - `menu_calculadora()` → `while True`: pide `a op b` o `Q` para salir.
- **Extras:** contar cuántas operaciones válidas se hicieron y su promedio de resultados.

---

## 13) Búsqueda de Patrón en Matriz de Caracteres
**Objetivo:** **ciclos anidados** + condicionales + funciones.
- **Entrada:** `F, C` y una matriz de caracteres (leída fila por fila). Un patrón lineal `P` (cadena).
- **Funciones:**
  - `contar_horizontal(F, C, P)` y `contar_vertical(F, C, P)` → cuentan coincidencias izquierda→derecha y arriba→abajo (permitir superposición).
  - (Opcional) `contar_diagonal(F, C, P)` → top-left → bottom-right.
- **Salida:** total de apariciones por orientación y total general.
- **Validaciones:** `len(P) ≤ max(F, C)` (si no, 0 apariciones).

---

## 14) Inventario Elemental con Comandos
**Objetivo:** `while True` + funciones con retorno y validaciones.
- **Funciones:**
  - `agregar(stock, u)` → retorna `stock + u` si `u>0`.
  - `vender(stock, u)` → retorna `stock - u` si `u>0` y hay stock suficiente; si no, retornar `stock` y un código de error.
  - `mostrar(stock)` → imprime.
- **Menú:** `A) Agregar`, `V) Vender`, `M) Mostrar`, `X) Salir`.  
- **Extra:** registrar la **venta más grande** y cuántas operaciones válidas se hicieron.

---

## 15) Estadística de Números con Tramos
**Objetivo:** funciones + anidados + condicionales.
- **Entrada:** cantidad `K` y luego `K` números reales.
- **Funciones:**
  - `clasificar_tramo(x)` → retorna etiqueta: `<0`, `0..9.99`, `10..99.99`, `≥100`.
  - `acumular_por_tramo(etiqueta, x)` → actualiza contadores/sumas por tramo.
- **Salida:** para cada tramo, conteo y promedio; global: mínimo, máximo y promedio general.

---

## 16) Menú Integrador (orquestador)
**Objetivo:** juntar todo en un solo programa.  
**Descripción:** Crea un **menú principal** que ofrezca ejecutar cualquiera de los ejercicios 1–15 y permita volver al menú tras terminar cada módulo.  
- **Requisitos:** `while True` en el menú, validaciones de opción, separación estricta en funciones, y mensajes claros de entrada/salida.

