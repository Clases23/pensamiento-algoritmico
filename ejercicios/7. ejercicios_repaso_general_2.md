# Taller de Repaso — Condicionales, Ciclos, Listas, Funciones y Matrices (9 puntos)

**Objetivo.** Practicar los fundamentos de programación: decisiones, repetición (incluyendo anidados), manejo de listas, definición/uso de funciones y recorrido de matrices.

**Reglas sugeridas**
- Lenguaje: **Python 3.x**.
- **Sin librerías externas** (solo estándar).
- Para afianzar ciclos, **EVITA** usar atajos como `sum`, `max`, `min` cuando el enunciado pida “usar bucles”.
- Escribe funciones *simples* y prueba con los ejemplos dados.

---

## Punto 1 — Signo y paridad (condicionales)
**Enunciado.** Dado un entero `n`, determina:
- si es **positivo**, **negativo** o **cero**;
- si es **par** o **impar** (si `n == 0`, considera “par”).

**Ejemplos**
- `n = 8` → “positivo” y “par”  
- `n = -3` → “negativo” y “impar”

**Plantilla (opcional)**
```python
def signo_y_paridad(n):
    # TODO: retorna (signo, paridad)
    ...
````

---

## Punto 2 — Clasificación de notas (condicional múltiple)

**Enunciado.** Recibe una nota en escala **0.0 a 5.0** y clasifícala:

* `>= 4.5` → “Excelente”
* `>= 4.0 y < 4.5` → “Sobresaliente”
* `>= 3.0 y < 4.0` → “Aprobado”
* `< 3.0` → “Reprobado”
  Si está **fuera de rango**, retorna “Inválida”.

**Ejemplos**

* `4.7` → “Excelente”
* `2.9` → “Reprobado”
* `5.3` → “Inválida”

**Plantilla**

```python
def clasificar_nota(nota):
    # TODO
    ...
```

---

## Punto 3 — Contar y sumar dígitos (ciclo while)

**Enunciado.** Para un entero **no negativo** `n`, calcula:

* cuántos **dígitos** tiene,
* la **suma** de sus dígitos.
  Usa **while** (sin convertir a string).

**Ejemplos**

* `n = 0` → dígitos: 1, suma: 0
* `n = 507` → dígitos: 3, suma: 12

**Plantilla**

```python
def info_digitos(n):
    # TODO: retorna (cantidad_digitos, suma_digitos)
    ...
```

---

## Punto 4 — Conteo de múltiplos en rango (for)

**Enunciado.** Dados dos enteros `a` y `b` (con `a <= b`), cuenta cuántos números en `[a, b]` son **múltiplos de 3** y cuántos son **múltiplos de 5** (independientes).

**Ejemplo**

* `a=1, b=15` → múltiplos de 3: 5 (3,6,9,12,15), múltiplos de 5: 3 (5,10,15)

**Plantilla**

```python
def contar_multiplos(a, b):
    # TODO: retorna (de_tres, de_cinco)
    ...
```

---

## Punto 5 — Patrón rectangular (ciclos anidados)

**Enunciado.** Imprime un **rectángulo** de `filas` × `columnas` usando `#`.
Ejemplo para `filas=3, columnas=5`:

```
#####
#####
#####
```

Usa **dos bucles anidados**.

**Plantilla**

```python
def rectangulo(filas, columnas):
    # TODO: construye y retorna el patrón con '\n' al final de cada fila
    ...
```

---

## Punto 6 — Resumen de lista (listas + bucles)

**Enunciado.** Dada una lista de enteros `xs`, calcula **sin** usar `sum/max/min`:

* suma total,
* máximo,
* mínimo,
* cantidad de positivos, negativos y ceros.

**Ejemplo**

* `xs = [3, -1, 0, 7, -5]` → suma: 4, max: 7, min: -5, pos: 2, neg: 2, ceros: 1

**Plantilla**

```python
def resumen_lista(xs):
    # TODO: (suma, maximo, minimo, cant_pos, cant_neg, cant_ceros)
    ...
```

---

## Punto 7 — Eliminar duplicados preservando orden (listas)

**Enunciado.** Dada una lista `xs`, crea una **nueva lista** sin elementos duplicados, **preservando el primer orden de aparición** (no usar `set`).

**Ejemplo**

* `[2, 3, 2, 5, 3, 3, 7]` → `[2, 3, 5, 7]`

**Plantilla**

```python
def sin_duplicados(xs):
    # TODO: recorre y agrega si aún no está en la nueva lista
    ...
```

---

## Punto 8 — Funciones: primo y factorial (for/while, sin recursión)

**Enunciado.**

1. Implementa `es_primo(n)` que retorne `True`/`False`.
2. Implementa `factorial(n)` para `n >= 0`.
3. Con ambas, define `resumen_numeros(xs)` que retorne:

   * cuántos son **primos**,
   * una **lista** con el factorial de cada `x` en `xs` (si `x` es grande, puedes asumir casos pequeños en pruebas).

**Ejemplo**

* `xs = [0, 1, 2, 3, 4]` → primos: 2 (`2,3`), factoriales: `[1,1,2,6,24]`

**Plantilla**

```python
def es_primo(n):
    # TODO
    ...

def factorial(n):
    # TODO
    ...

def resumen_numeros(xs):
    # TODO: (cuantos_primos, factoriales)
    ...
```

---

## Punto 9 — Operaciones con matriz cuadrada (sin diagonales)

**Enunciado.** Para una **matriz cuadrada** `M` (lista de listas), calcula:

* suma de cada **fila** (lista),
* suma de cada **columna** (lista),
* el **mayor** valor y su **posición** `(i, j)`,
* el **menor** valor y su **posición** `(i, j)`.

**Ejemplo**
`M = [[1,2,3],[4,5,6],[7,8,9]]`

* filas: `[6, 15, 24]`, columnas: `[12, 15, 18]`, mayor: `9` en `(2,2)`, menor: `1` en `(0,0)`

**Plantilla**

```python
def analisis_matriz_cuadrada(M):
    """
    Retorna:
    (s_filas, s_columnas, mayor, (i_max, j_max), menor, (i_min, j_min))
    """
    # TODO
    ...
```

---

## Sugerencias de verificación rápida (no entregables)

* Prueba funciones con los ejemplos dados y con casos borde (p.ej., listas vacías, `n=0`, matrices 1×1).
* Para matrices, verifica que **todas las filas** tengan la misma longitud antes de operar.

---

