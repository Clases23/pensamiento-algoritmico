
# Variables: Conceptos Básicos, Uso en Python y Buenas Prácticas

## 1. Introducción general al concepto de **variable**

En términos generales, una **variable** es cualquier elemento que puede cambiar o tomar diferentes valores. Fuera del contexto de programación, el término se utiliza para referirse a una cantidad o propiedad susceptible de variar dentro de cierto conjunto de valores. Por ejemplo, en matemáticas una variable suele representarse con una letra (como *x* o *y*) cuyo valor puede cambiar dentro de una ecuación. En ciencias experimentales, hablamos de variables para referirnos a factores que pueden tomar distintos valores: por ejemplo, la temperatura y la presión en un experimento son variables que cambian y afectan los resultados. En estadística, una variable puede ser una característica medida de individuos (edad, estatura, peso, etc.), la cual varía de un individuo a otro. Lo importante es que el valor de una variable *no es fijo*, sino que **puede cambiar o ser diferente según las circunstancias**. Por contraste, una **constante** es un valor que no cambia (por ejemplo, el número π es aproximadamente 3.1416 siempre, y no varía de un caso a otro).

En resumen, en la vida diaria y en la ciencia, una variable es **algo que puede variar o cambiar su valor** según el contexto. Esto nos da la idea fundamental que se lleva al mundo de la programación: la necesidad de elementos que actúen como *contenedores* de información cuyo contenido puede modificarse durante la ejecución de un proceso.

## 2. ¿Qué es una variable en **programación**?

En programación, **una variable es un nombre simbólico que representa un dato almacenado en la memoria, cuyo valor puede cambiar durante la ejecución de un programa**. Podemos imaginar una variable como un **contenedor o caja etiquetada** donde colocamos información para usarla en nuestro programa. Al igual que una caja física, la variable tiene:

* **Nombre** (la etiqueta de la caja): es el identificador único con el que nos referimos a ese dato en el código. Por ejemplo, podemos llamar `puntaje` a una variable que guarda la puntuación de un jugador. El nombre de variable permite al programador y al programa **acceder** a ese valor sin conocer detalles de la dirección de memoria donde se guarda (más sobre esto en la siguiente sección). Los nombres de variables suelen seguir ciertas reglas y convenciones (como veremos en secciones posteriores).

* **Tipo de dato** (el tipo de contenido que guarda la caja): cada variable almacena un dato de un cierto tipo (número, texto, etc.). El **tipo** determina las características del dato (por ejemplo, si es un número entero, un número con decimales, una cadena de caracteres, un valor lógico *True/False*, etc.) y las operaciones válidas que se pueden hacer con él. En algunos lenguajes, el tipo de la variable es fijo una vez declarado; en otros (como Python) el tipo se asocia al valor y la variable puede referirse a distintos tipos en distintos momentos (lo veremos en detalle más adelante). En cualquier caso, el **tipo de dato** nos indica la naturaleza del valor almacenado.

* **Valor** (el contenido actual de la caja): es el dato específico que la variable guarda en un momento dado. El valor de una variable puede cambiar a lo largo del programa mediante operaciones de asignación. Por ejemplo, la variable `puntaje` podría valer 0 al inicio, luego incrementarse a 10, 50, 100, etc. conforme avanza el juego. Inicialmente, la variable puede incluso no tener valor hasta que se le asigne uno. Cuando decimos que “una variable *almacena* un valor”, nos referimos a que en memoria hay un dato asociado a ese nombre de variable.

* **Mutabilidad**: este término hace referencia a si el *valor en sí* puede ser modificado directamente o no una vez creado. Es importante diferenciar que aquí hablamos de modificar el contenido **sin reemplazar la variable completa**. En muchos lenguajes, las variables en sí mismas son reasignables (podemos hacer que un nombre apunte a un dato distinto). Pero algunos *tipos de datos* son **inmutables**, lo que significa que una vez creado un valor de ese tipo, no se puede cambiar su contenido interno; cualquier "cambio" produce en realidad un nuevo valor (por ejemplo, en Python, las cadenas de texto son inmutables: si “modificamos” una cadena, en realidad obtenemos una nueva cadena y la antigua permanece intacta). Otros tipos son **mutables**, lo que permite alterar el contenido en memoria sin crear un objeto nuevo (por ejemplo, en Python las listas son mutables: podemos cambiar uno de sus elementos y la misma lista se actualiza). En el contexto general de variables, podemos notar la diferencia entre una **variable variable** y una constante: la variable puede tomar diferentes valores a lo largo del tiempo, mientras que la constante permanece igual. Durante la ejecución del programa, las variables que pueden cambiar de valor son esenciales para representar información dinámica (por ejemplo, la puntuación de un juego que sube y baja). En cambio, si un dato no debe cambiar nunca, podría manejarse como constante para mayor seguridad. (En Python no existe un tipo especial de constante, pero por convención se usan nombres en mayúsculas para indicar que no deberíamos cambiar ese valor).

**Analogía:** Una manera intuitiva de entender las variables es pensar en una **caja con una etiqueta**. La etiqueta es el nombre de la variable, y dentro de la caja está el valor que queremos guardar. Podemos abrir la caja para leer qué hay (acceder al valor) o para meter algo diferente (cambiar el valor). Por ejemplo, imaginemos una caja etiquetada como "puntuación". Al iniciar un juego, ponemos dentro el número 0. Conforme el jugador gana puntos, abrimos la caja y reemplazamos el contenido por el nuevo puntaje (10, luego 50, luego 100, etc.). Siempre nos referimos a la caja por su nombre "puntuación", y no nos importa exactamente **dónde** está la caja físicamente, solo qué tiene dentro. Esa abstracción es fundamental en programación: nos permite trabajar con datos de forma clara sin preocuparnos por los detalles de bajo nivel. Como señala una referencia, *“otra manera de definir una variable es como una caja vacía en la que se guardará un dato, que luego puede cambiarse por otro... en el ejemplo de la puntuación del videojuego, imaginemos la caja con el rótulo 'puntuación' y adentro un número; no importa si ese número es 10, 157 o 2345, lo importante es saber que representa la puntuación del jugador”*.

**Resumen:** En programación, una variable es una entidad fundamental que sirve para **almacenar información bajo un nombre**, pudiendo recuperar o modificar dicha información a lo largo de la ejecución. Las variables tienen un tipo de dato asociado, un valor en un momento dado, y se utilizan para hacer que los programas sean generales y puedan manejar datos que cambian (por ejemplo, datos de entrada del usuario, resultados de cálculos, conteos, etc.). Sin variables, los programas serían mucho menos flexibles, ya que estarían limitados a valores fijos. Es por ello que aprender a usarlas correctamente es de las primeras tareas de cualquier programador novel.

## 3. Representación de las variables en **memoria**

Cuando un programa se ejecuta, toda la información (código y datos) reside en la **memoria principal (RAM)** del computador. Una variable, al fin y al cabo, es un dato almacenado en memoria, por lo que es útil entender cómo se relacionan las variables con la memoria. Podemos desglosarlo así:

* **Direcciones de memoria:** La memoria de la computadora está dividida en celdas o posiciones consecutivas, cada una con un número único llamado **dirección**. Podemos imaginar la memoria como una serie de casilleros numerados. Cada casillero almacena un dato básico (por ejemplo, 1 byte = 8 bits en la mayoría de las arquitecturas modernas). Si un dato es más grande que lo que cabe en una celda, ocupará varias celdas contiguas. Cada celda tiene su dirección (normalmente expresada en formato hexadecimal, e.g. `0x1A2F`), que es como su "coordenada" dentro de la RAM. Internamente, todo lo que maneja la computadora se representa en *bits* (0s y 1s); por ejemplo, el número binario `01010010` podría representar un valor numérico (82 en decimal) o un carácter ('R'), según cómo se interprete. La memoria *no sabe* de tipos, solo almacena bits; es el programa (y el lenguaje) el que interpreta esos bits según el tipo de dato definido.

* **Variables y direcciones:** Cuando definimos una variable en un programa, el lenguaje asocia ese **nombre de variable** con una ubicación de memoria donde se almacena su valor. En lenguajes de bajo nivel (como C), podríamos obtener la dirección de memoria de una variable directamente (usando el operador `&` en C, por ejemplo) – es decir, el programador puede trabajar con direcciones si lo requiere. En lenguajes de alto nivel (como Python), normalmente no nos preocupamos por la dirección exacta; el intérprete/compilador gestiona eso por nosotros. **El sistema operativo y el entorno de ejecución** se encargan de reservar un espacio de memoria para cada variable cuando se necesita, y liberarlo cuando ya no se usa. *Durante la ejecución del programa, el sistema operativo gestiona la memoria y decide en qué parte guardará cada dato*, dependiendo de qué áreas de memoria estén libres, entre otros factores. Por ello, **el programador no sabe ni necesita saber la dirección de memoria exacta** donde va a parar cada variable; simplemente utiliza el nombre de la variable para referirse al dato, y el sistema encuentra el dato en memoria por nosotros.

* **Nombres simbólicos (identificadores):** Dado que las direcciones de memoria son números poco intuitivos y variables en cada ejecución, los lenguajes introducen los **identificadores** (nombres de variables) como una abstracción. Al compilar o interpretar el código, cada nombre de variable se **vincula a una dirección de memoria concreta**. Así, cuando en el código escribimos `puntaje = 0`, el programa reserva una ubicación de memoria disponible y guarda el valor 0; a la vez, registra que el nombre `puntaje` apunta a esa dirección. Si luego hacemos `puntaje = 50`, el programa puede almacenar 50 (quizás en la misma dirección u otra, según el lenguaje y si el tipo cambió) y actualizar la referencia del nombre. Como menciona una fuente, para evitar lidiar directamente con direcciones cambiantes *“se le da un nombre simbólico o identificador al dato; esto es lo que conocemos como variable. El programador puede decir que ese dato se identificará con el nombre 'puntaje', independientemente de dónde quede en memoria”*. En otras palabras, la **variable conecta un nombre en el código con una ubicación en memoria** de forma flexible.

* **Interpretación según el tipo:** Ya que la memoria almacena solo bits, ¿cómo sabe el programa qué significa un patrón de bits dado? Ahí entra el rol del **tipo de dato**. Cuando declaramos una variable con cierto tipo (o cuando el lenguaje infiere el tipo, como en Python), se entiende que los bits almacenados deben interpretarse de esa manera. Por ejemplo, los bits `01010010` podrían interpretarse como el número 82 si la variable es de tipo entero, o como la letra 'R' si la variable es de tipo carácter. El lenguaje define tamaños típicos para cada tipo (e.g. quizá 32 bits para un entero en cierto lenguaje). En lenguajes estáticamente tipados, al reservar la memoria para la variable también se sabe cuánto espacio ocupará según su tipo. En lenguajes dinámicamente tipados como Python, el tipo es una propiedad del valor más que del nombre, pero internamente las estructuras de datos Python manejan el tamaño y representación del objeto en memoria.

En resumen, **una variable es una referencia a un espacio de memoria donde se guarda un valor**. Como programadores normalmente nos referimos a las variables por nombre, y el sistema se encarga de traducir eso a direcciones de memoria reales. Cuando actualizamos una variable con un nuevo valor, el contenido en memoria cambia (o la variable pasa a apuntar a otra ubicación con el nuevo valor, dependiendo del modelo del lenguaje). Cuando dejamos de necesitar una variable, el espacio de memoria eventualmente puede ser liberado (por el *garbage collector* en Python, por ejemplo).

**Relación con el sistema operativo y el intérprete:** El *sistema operativo (SO)* proporciona al programa un espacio de direcciones de memoria para que use durante su ejecución. El programa (o su intérprete/compilador) solicita al SO bloques de memoria conforme necesita (por ejemplo, al crear nuevas variables u objetos). En Python, existe un **administrador de memoria** y un **recolector de basura** (*garbage collector*) dentro del intérprete que manejan la asignación y liberación de memoria automáticamente. El programador, por lo tanto, no tiene que reservar ni liberar memoria manualmente para variables simples – esto ocurre detrás de escena. Por otro lado, en lenguajes como C, el programador tiene más control (y responsabilidad) sobre la memoria: aunque las variables locales se asignan automáticamente en la *pila* al entrar en un bloque y se liberan al salir, si se solicitan bloques dinámicos (en el *heap*) con funciones como `malloc`, el programador debe liberar esa memoria con `free` para evitar fugas. Afortunadamente, en Python este manejo es automático. A un nivel conceptual básico, podemos quedarnos con la idea de que **cada variable ocupa un lugar en la memoria** y que el **nombre de la variable** es la manera de acceder a ese lugar sin tener que saber su dirección numérica.

*Nota:* Aunque no profundizaremos, vale mencionar que dependiendo del **alcance (scope)** y tipo de la variable, la memoria donde se guarda puede ser diferente (pila, heap, segmentos estáticos, etc.). Por ejemplo, en C una variable local a una función suele vivir en la pila, mientras que una variable global o estática vive en una región fija. En Python, todos los objetos (que incluyen los valores de variables) se almacenan en el *heap* administrado por Python, y las referencias/nombres siguen ciertas reglas de alcance. Estas sutilezas importan más al optimizar o entender comportamiento avanzado; en un primer acercamiento, podemos imaginar simplemente que todas las variables están en "la memoria" y funcionan como cajas con valores que el sistema localiza por nosotros.

## 4. **Variables en Python**

En el lenguaje Python, el manejo de variables tiene particularidades importantes que lo diferencian de otros lenguajes comunes. A continuación, exploraremos cómo funcionan las variables en Python en cuanto a **declaración**, **tipado**, **tipos de datos disponibles**, **mutabilidad**, **ámbito**, y operaciones de **reasignación** y **eliminación**:

### Declaración y asignación de variables en Python

Una de las características de Python es que **no requiere una declaración explícita de variables antes de usarlas**. En muchos lenguajes (C, Java, etc.) debemos *declarar* la variable indicando su tipo y nombre antes de asignarle un valor. En Python, en cambio, basta con **asignar un valor a un nombre** para crear la variable sobre la marcha. Por ejemplo:

```python
# Ejemplo de asignación en Python:
x = 5        # crea la variable 'x' y le asigna el entero 5
x = "Hola"   # ahora 'x' referencia un nuevo valor, la cadena "Hola"
```

En el ejemplo, inicialmente `x` era un entero con valor 5, luego se reutiliza el mismo nombre `x` para guardar la cadena `"Hola"`. Python *inferirá* automáticamente el tipo de dato según el valor asignado (entero para 5, cadena para "Hola"). **No se especifica el tipo en el código fuente**, a diferencia de, por ejemplo, C donde haríamos `int x = 5;` y no podríamos asignar luego `x = "Hola"` porque el tipo de `x` está fijo como entero. En Python, el tipo es dinámico (cambiable) y viene dado por el valor actual de la variable. Esta comodidad tiene el beneficio de hacer el código más simple y flexible, aunque requiere que el programador sea cuidadoso con qué valores asigna a cada nombre.

Internamente, cuando haces una asignación `nombre = valor` en Python, el intérprete crea un objeto en memoria para almacenar ese `valor` (si no existía ya un objeto igual) y luego hace que el **nombre de variable** referencie (apunten a) ese objeto. Si luego asignas otro valor a la misma variable, el nombre se "desvincula" del objeto anterior y pasa a referenciar el nuevo objeto. (Los objetos a los que ya no apunta ninguna variable quedan candidatos para ser liberados por el *garbage collector*). Esto significa que **los nombres en Python son básicamente referencias a objetos en memoria**, más que contenedores que almacenan directamente un valor en un lugar fijo.

En Python **no existe un comando especial para declarar** una variable sin asignarla; la declaración ocurre implícitamente con la primera asignación. Si intentamos usar una variable que nunca hemos asignado, obtendremos un error `NameError` indicando que el nombre no está definido. Por ejemplo:

```python
print(a)    # Error, 'a' no está definida
a = 10      # a partir de aquí, 'a' existe
print(a)    # Muestra 10
```

Esta filosofía "asignación = declaración" hace que la sintaxis de Python sea muy limpia. Sin embargo, el programador debe evitar errores tipográficos en los nombres (porque si por accidente escribe otro nombre, Python no se quejará hasta que intente usar ese nombre no inicializado).

En resumen: **en Python creamos una variable simplemente asignándole un valor**, sin necesidad de declarar tipo ni usar palabras clave especiales. El tipo asociado puede cambiar luego si se asigna otro valor. Esta característica ilustra el tipado dinámico de Python.

### Tipado dinámico y fuerte de Python

**Tipado dinámico:** Python es un lenguaje de **tipado dinámico**, lo que significa que el tipo de dato de una variable (más propiamente dicho, del valor al que referencia) puede cambiar en tiempo de ejecución. Como vimos, podemos asignar un entero a `x` y luego una cadena, y Python no pone impedimentos en tiempo de compilación porque las variables no tienen un tipo fijo asociado. Cada objeto en Python conoce su propio tipo, y una variable es libre de apuntar a objetos de distintos tipos en distintos momentos. Veamos un ejemplo que demuestra esto usando la función `type()` para inspeccionar el tipo de un objeto:

```python
a = 5
print(type(a))   # <class 'int'>  (a es un entero)
a = "Hola mundo"
print(type(a))   # <class 'str'>  (ahora a es una cadena de caracteres)
```

Como se observa, la **misma variable `a` cambió su tipo** cuando se le asignó un valor de tipo distinto. En un lenguaje de **tipado estático** (como Java o C++), esto no sería permitido; la variable tendría un tipo declarado y fijo (por ejemplo, `int a`), de modo que hacer `a = "Hola mundo"` sería un error en tiempo de compilación. Python, al ser dinámico, retrasa la verificación de tipos al momento de ejecutar las operaciones. Esto da mucha flexibilidad, aunque puede trasladar ciertos errores al tiempo de ejecución si no se tiene cuidado.

**Tipado fuerte:** Además de dinámico, Python es un lenguaje de **tipado fuerte**. El **tipado fuerte** implica que **no se realizan conversiones implícitas entre tipos incompatibles**; si intentamos combinar dos objetos de tipos no compatibles en una operación, Python lanzará un error en lugar de intentar forzar una conversión. Por ejemplo, no podemos sumar un número y una cadena directamente:

```python
a = 5
b = "7"
# print(a + b)  # Descomentar esta línea causaría TypeError, no se puede sumar int + str
```

En el ejemplo, `a+b` no es válido porque Python no sabe sumar un entero con una cadena; tendríamos que convertir la cadena `"7"` a número entero o convertir el número `5` a cadena, según lo que queramos (concatenar como texto o sumar numéricamente). En lenguajes de **tipado débil** como JavaScript, la expresión `5 + "7"` **sí** produce un resultado (en JavaScript daría la cadena `"57"` por conversión automática del 5 a texto). Python deliberadamente *no* hace esa conversión mágica; prefiere que el programador sea explícito, lo cual previene posibles confusiones o errores silenciosos. Si queremos concatenar el 5 y "7" como texto en Python haríamos `str(a) + b` obteniendo `"57"`, y si quisiéramos sumarlos numéricamente haríamos `a + int(b)` obteniendo `12`. Pero Python no elegirá por sí solo una de esas interpretaciones: simplemente da error para indicar *"estas dos cosas no se pueden combinar tal cual"*.

En resumen, el **sistema de tipos de Python** se caracteriza por: (a) ser dinámico (las variables pueden referir a distintos tipos en distintos momentos, y los tipos se comprueban en tiempo de ejecución), y (b) ser fuerte o estricto en cuanto a que no mezcla tipos incompatible automáticamente. Esto significa que Python nos da flexibilidad pero nos exige coherencia en las operaciones. Esta combinación difiere de lenguajes estáticamente tipados (C/Java) donde el tipo es fijo pero a veces hay conversiones implícitas (por ejemplo, en C `int` y `float` pueden mezclarse en expresiones con conversión automática a `float`), o de lenguajes dinámicos débilmente tipados (like JavaScript) donde el tipo puede cambiar *y* además el lenguaje hace conversiones por uno. Python es dinámico pero nos pide conversiones explícitas si son necesarias, lo cual es considerado una buena práctica para mantener claridad.

**Ventajas y desventajas:** Para un programador principiante, el tipado dinámico suele ser más fácil al comienzo, porque “todo funciona” sin declarar tipos y puede usar variables libremente. Sin embargo, a medida que un programa crece, esa misma flexibilidad puede ocasionar errores si, por ejemplo, sin querer usamos un valor de tipo inesperado en cierta parte del código. Los lenguajes estáticos habrían atrapado ese error antes de ejecutar. En Python, existen herramientas como *type hints* (anotaciones de tipos opcionales) y linters estáticos (`mypy`, etc.) que permiten obtener algo de verificación de tipos antes de correr el programa, pero son opcionales. En cualquier caso, entender la naturaleza dinámica de Python es clave: **el tipo viaja con el objeto, no con la variable**. Una variable es más bien una etiqueta que apunta a un objeto de cierto tipo en cada momento.

### Tipos de datos admitidos en Python

Python ofrece una variedad de **tipos de datos** integrados para usar en las variables. Enumeremos los principales tipos básicos:

* **Numéricos:** Python maneja enteros (**`int`** para números enteros de precisión ilimitada), números de coma flotante (**`float`** para números reales de doble precisión, típicamente), y números complejos (**`complex`**, con parte real e imaginaria). Los enteros en Python pueden ser arbitrariamente grandes (no están limitados a 32 bits, por ejemplo), lo cual es muy útil en cálculos matemáticos sin desbordamientos. También existe el tipo **`bool`** (booleano) para valores lógicos `True` o `False`, que conceptualmente es numérico (subtipo de int, donde `True` equivale a 1 y `False` a 0), aunque se usa para lógica booleana.

* **Texto (cadenas de caracteres):** El tipo **`str`** en Python representa cadenas de texto (secuencias de caracteres Unicode). Las cadenas pueden delimitarse con comillas simples o dobles indistintamente (`'hola'` o `"hola"`). Son inmutables (no se pueden modificar en sitio, cada operación que parece modificarlas devuelve una nueva cadena).

* **Secuencias y colecciones:** Python tiene varios tipos para representar colecciones de elementos:

  * **Listas (`list`)**: secuencias ordenadas de elementos de cualquier tipo, mutable (se pueden cambiar, agregar, quitar elementos). Se definen con corchetes, e.g. `[1, 2, 3]`.
  * **Tuplas (`tuple`)**: secuencias ordenadas inmutables. Se definen normalmente con paréntesis, e.g. `(1, 2, 3)`. Una tupla una vez creada no puede alterarse (lo que la hace útil para datos que no deben cambiar).
  * **Conjuntos (`set`)**: colecciones no ordenadas de elementos únicos, mutables. Útiles para pruebas de pertenencia y eliminar duplicados. Se definen con llaves `{}` o usando la función `set()`.
  * **Diccionarios (`dict`)**: estructuras de mapeo clave-valor. Son mutables. Permiten asociar una **clave** (por ejemplo, una cadena) con un **valor** (cualquier objeto). Se definen con `{clave: valor}`. Ejemplo: `{'nombre': 'Ana', 'edad': 25}`.
  * **Range (`range`)**: tipo que representa una secuencia de números enteros en un intervalo (se usa comúnmente en bucles for).

* **Tipo especial `NoneType`:** Python tiene un valor especial **`None`** que representa "ausencia de valor" o "valor nulo". Es un objeto único de tipo `NoneType`. A veces se usa para inicializar variables que luego tendrán otro valor, o para indicar un resultado vacío.

Además de estos, Python ofrece tipos binarios (bytes, bytearray para secuencias de bytes), tipos para manejar fechas, decimales con precisión fija, etc., mediante clases y módulos especializados. Pero los mencionados arriba son los fundamentales incorporados.

Al declarar (asignar) una variable en Python, el tipo del objeto asignado determina el “tipo de la variable” en ese momento. Es importante entender que **todo en Python es un objeto**, incluso los tipos primitivos. Esto significa que las variables realmente almacenan referencias a objetos que tienen propiedades y métodos. Por ejemplo, una cadena `s = "hola"` es un objeto de la clase `str` y tiene métodos como `s.upper()` para convertir a mayúsculas, etc.

**Literales y asignación múltiple:** Python permite asignar múltiples variables a la vez. Por ejemplo `x, y, z = 1, "texto", 3.5` asigna 1 a `x` (int), "texto" a `y` (str), 3.5 a `z` (float). También es posible hacer que varias variables referencien el mismo objeto: `a = b = 0` hace que tanto `a` como `b` apunten al mismo entero 0 (que es un objeto inmutable; en este caso no importa, pero si fuera un objeto mutable, cambiarlo vía `a` afectaría a `b` también porque es el mismo objeto).

En síntesis, Python admite todos los tipos necesarios para programar a alto nivel: numéricos, texto, colecciones, booleanos, y más. Las variables pueden en un momento dado contener un objeto de cualquiera de estos tipos. Más adelante, uno puede definir **tipos propios** (clases) y entonces las variables pueden contener instancias de esas clases también – pero eso excede este repaso inicial.

### Mutabilidad vs. inmutabilidad de las variables (u objetos) en Python

Como mencionamos, **mutabilidad** se refiere a la capacidad de un objeto de ser modificado después de su creación. En Python, esto no es una propiedad de la variable en sí (ya que una variable puede siempre ser reasignada a otro objeto), sino del **objeto al que la variable apunta**. En otras palabras, la pregunta es: dado un objeto, ¿puede cambiar su *contenido interno* sin cambiar de identidad? Si sí, el objeto es mutable; si no, es inmutable.

* **Objetos mutables:** *Su contenido se puede alterar* tras su creación, sin cambiar el objeto en sí (la variable sigue apuntando al mismo objeto, que ahora internamente es distinto). Algunos ejemplos de objetos mutables en Python son **listas**, **diccionarios** y **conjuntos (sets)**. Por ejemplo, una lista `[1, 2, 3]` es mutable: podemos hacer `lista[0] = 99` y ahora la lista es `[99, 2, 3]` sin haber creado una lista nueva, simplemente modificamos la existente en memoria. Lo mismo con un diccionario: podemos agregar o cambiar pares clave-valor dentro del mismo dict. La mutabilidad es útil para estructuras de datos que acumulen o cambien información sobre la marcha.

* **Objetos inmutables:** *No se pueden modificar una vez creados*. Cualquier "cambio" genera en realidad un **nuevo objeto**. En Python son inmutables tipos básicos como los **enteros**, **flotantes**, **booleanos**, **cadenas de caracteres (`str`)** y **tuplas**, entre otros. Por ejemplo, si tienes `texto = "Hola"`, esa cadena no puede cambiar; si haces `texto += " Mundo"`, Python crea una nueva cadena `"Hola Mundo"` y hace que `texto` ahora apunte a la nueva cadena, pero la original `"Hola"` quedó intacta (y eventualmente será limpiada de memoria si ninguna variable la referencia). Similarmente, si tienes una tupla `(1, 2, 3)`, no puedes asignar a `tupla[0]` un nuevo valor porque esa operación no está permitida (provocaría un error). Para "modificar" una tupla tendrías que construir una tupla nueva con los cambios deseados.

¿Por qué es relevante esto? Porque afecta el comportamiento de las variables y las operaciones:

* Si una variable apunta a un objeto mutable, **puedes cambiar el contenido de ese objeto sin cambiar la variable de objeto**. Por ejemplo, `lista = [1, 2, 3]`; si luego haces `lista.append(4)`, la variable `lista` sigue apuntando al *mismo* objeto lista, pero su contenido ahora es `[1, 2, 3, 4]`. Cualquier otra variable que apuntara a esa misma lista también vería el cambio.
* Si una variable apunta a un objeto inmutable, no hay forma de alterar ese objeto. Si "cambias" la variable, en realidad estás creando otro objeto. Por ejemplo, `a = 5`; si luego haces `a = a + 1`, el entero 5 nunca cambió (los enteros son inmutables), simplemente se creó un nuevo entero 6 y `a` ahora referencia 6. Otro ejemplo: `s = "abc"`, `s_upper = s.upper()`. El método `.upper()` devuelve una nueva cadena `"ABC"`; la cadena original `"abc"` permanece existente e inmutable. Saber esto ayuda a evitar confusiones, por ejemplo al tratar de modificar una cadena en el lugar (no se puede, hay que crear una nueva).

Listemos algunos tipos mutables e inmutables frecuentes en Python:

* **Mutables:** listas (`list`), diccionarios (`dict`), conjuntos (`set`), bytearrays, y en general casi cualquier objeto *personalizado* puede definirse mutable.
* **Inmutables:** enteros (`int`), flotantes (`float`), booleanos (`bool`), cadenas (`str`), tuplas (`tuple`), conjuntos inmutables (`frozenset`), bytes, y también los nombres de funciones, clases, etc., son objetos que no se modifican después de creados.

**Ejemplo ilustrativo:**

```python
# Mutable vs Inmutable example
lista = [1, 2, 3]
otra_lista = lista
lista[0] = 99
print(otra_lista)   # Salida: [99, 2, 3]  (ambas variables ven el cambio porque es el mismo objeto mutable)

tupla = (1, 2, 3)
otra_tupla = tupla
tupla = tupla + (4,)   # crea una nueva tupla (1,2,3,4)
print(otra_tupla)  # Salida: (1, 2, 3)  (la tupla original referenciada por otra_tupla no cambió)
print(tupla)       # Salida: (1, 2, 3, 4) (tupla ahora apunta a un objeto nuevo)
```

En el código anterior, modificamos la lista y afectó a ambas referencias, pero al "modificar" la tupla, en realidad la variable `tupla` cambió de objeto, sin afectar a `otra_tupla` que seguía apuntando al objeto original inmutable.

**En términos de variables:** podríamos decir que *"en Python, las variables *no* son mutables ni inmutables; los objetos sí"*. Cualquier variable puede reasignarse para apuntar a otra cosa (lo cual es un cambio para la variable, claro está). Pero cuando dos variables apuntan al mismo objeto, si ese objeto es mutable, cambiarlo vía una variable se refleja al accederlo vía la otra. Si es inmutable, no hay tal riesgo porque nunca se modifica en sitio.

En cuanto a diseño de software, usar objetos inmutables tiene ventajas de seguridad (saber que algo no cambiará accidentalmente) y facilidad para usar como claves en diccionarios o elementos de conjuntos (se requiere que sean inmutables para calcular su hash). Los mutables son necesarios cuando sí se requiere actualizar estructuras de datos sin recrearlas completas (por eficiencia o conveniencia).

El programador debe ser consciente de la mutabilidad para evitar efectos inesperados. Por ejemplo, al pasar una lista a una función, si la función la modifica, esa modificación persistirá fuera de la función porque lista es mutable (a menos que se haga una copia). Con inmutables (como números o strings), al pasarlos a una función y "modificarlos" simplemente se crea un nuevo objeto local, sin impacto afuera.

En síntesis: **mutabilidad** determina si un objeto *referenciado por una variable* puede cambiar internamente. Python proporciona ambos tipos; entender cuáles tipos son mutables e inmutables es parte del dominio del lenguaje y crucial para un manejo correcto de las variables.

### Ámbito (*scope*) de las variables en Python

El **ámbito** de una variable se refiere a la región del programa en la cual esa variable es **visible** (accesible). Python maneja principalmente dos niveles de alcance para variables ordinarias: **global** y **local**. (También existe el alcance "no local/enclosing" para funciones anidadas y un ámbito especial para nombres *built-in*, pero nos centraremos en los dos principales).

* **Variables globales:** Son las variables definidas en el cuerpo principal del código o módulo, fuera de cualquier función (o también fuera de clases). Tienen alcance global, es decir, pueden ser leídas desde *cualquier parte* del programa, incluso dentro de funciones (aunque si se quieren modificar dentro de una función se necesita una declaración especial, veremos eso). En un programa simple de un solo archivo, podríamos llamar variables globales a las definidas al inicio del script. Por ejemplo, `PI = 3.1416` definida en el nivel superior es global.

* **Variables locales:** Son las variables definidas *dentro de una función* (o de un bloque de código como comprensión de listas, etc.). Su alcance está limitado a esa función: existen solo mientras la función se ejecuta, y fuera de la función no se pueden ver ni usar. Por ejemplo, en la función `def area_circulo(r): resultado = 3.1416 * r*r` la variable `resultado` es local a esa función; al terminar la función, `resultado` deja de existir (o más técnicamente, ya no es accesible).

**Básicamente**, cuando el intérprete de Python ve un nombre de variable dentro de una función, primero busca si es una variable local (definida allí mismo); si no, busca en los ámbitos externos (funciones que engloben, si las hay, y finalmente el global). Esto se conoce como regla LEGB (Local, Enclosing, Global, Built-in) de resolución de nombres. Para la mayoría de casos iniciales: una variable asignada dentro de una función es local a ella, y una variable asignada fuera es global.

Ejemplo ilustrativo de ámbito:

```python
x = 5            # variable global

def mi_funcion():
    y = 10       # variable local a mi_funcion
    print("Dentro de la función, x vale:", x)   # puede leer x global
    print("Dentro de la función, y vale:", y)   # y existe aquí

mi_funcion()
print("Fuera de la función, x vale:", x)   # x global accesible fuera
# print(y)  # ESTO DARÍA ERROR, y no existe fuera de la función
```

Salida esperada:

```
Dentro de la función, x vale: 5  
Dentro de la función, y vale: 10  
Fuera de la función, x vale: 5  
```

Y efectivamente, si descomentáramos `print(y)` fuera de la función obtendríamos `NameError` porque `y` es local a la función.

Como se ve, **una función puede acceder a variables globales para lectura**. Sin embargo, si intentamos asignar a una variable global dentro de una función, Python por defecto *creará una variable local nueva con ese mismo nombre*, en lugar de afectar la global. Por ejemplo, si en el código anterior dentro de `mi_funcion` hiciéramos `x = 7`, Python interpretaría que estamos definiendo una nueva `x` local (que *sombraría* a la `x` global dentro de la función). Para aclararle a Python que queremos usar la `x` global dentro de la función (por ejemplo, modificarla), tendríamos que declarar `global x` al inicio de la función. Esa declaración le indica al intérprete que `x` no es una nueva variable local, sino la global de siempre. Usándolo con cuidado, podemos entonces modificar variables globales dentro de funciones. Sin la declaración `global`, cualquier asignación a `x` dentro de la función sería considerada una variable distinta (local), dejando intacta la global.

**¿Por qué existe esta distinción?** Por organización y evitar errores: las funciones idealmente operan sobre parámetros y variables propias sin depender demasiado de variables globales (esto mejora la modularidad). Las variables globales en Python viven mientras el programa se ejecuta (o el módulo está importado), en cambio las locales viven solo en cada llamada de función (cada vez que llamas a la función, se crea un nuevo conjunto de variables locales, que se destruyen al terminar la ejecución de esa llamada). Esto también significa que dos llamadas sucesivas a la misma función no comparten las variables locales entre sí (a menos que sean atributos estáticos o globales).

**Ámbito en bucles y condicionales:** A diferencia de algunos lenguajes, en Python las estructuras de control (`if`, `for`, `while`, etc.) *no* crean un nuevo ámbito local. Es decir, si dentro de un `if` defines `a = 5`, esa `a` es la misma variable del bloque envolvente (por ejemplo, la función o el global). Lo mismo en un `for`: si haces `for i in range(3): ...`, tras el bucle la variable `i` seguirá existiendo con su último valor. Esto sorprende a quienes vienen de C/Java donde las variables definidas dentro de un bloque `{ ... }` dejan de existir al salir del bloque. En Python no hay llaves para delimitar scope; el scope local solo lo crean las definiciones de funciones, clases, y módulos. Esto significa que hay que tener cuidado de no reutilizar nombres dentro de bucles si no se desea que persistan luego.

**Variables en funciones anidadas:** (tema un poco más avanzado) Python permite definir funciones dentro de funciones. En ese caso hay un alcance intermedio "nonlocal" o "enclosing": la función interna puede ver variables de la función externa (pero no modificarlas libremente a menos que use la palabra clave `nonlocal`). Esto es un detalle de cierre lexical; mencionarlo completo sale del alcance de estas notas, pero la idea es que Python maneja esos niveles también. Para el 99% de los casos en un primer curso: global vs local será la distinción relevante.

**Buenas prácticas de ámbito:** En general, es recomendable **minimizar el uso de variables globales**, ya que complican el seguimiento del estado del programa. Es mejor pasar valores a las funciones mediante parámetros y retornarlos mediante el resultado, manteniendo la mayor parte de las variables como locales. Las variables globales pueden usarse para constantes u objetos que verdaderamente deban ser únicos en todo el programa. Python no impide usar globales, pero hacerlo en exceso puede volver difícil entender quién modifica qué. Como curiosidad, en Python no existe un mecanismo de *encapsulamiento* estricto de variables como en otros lenguajes (por ejemplo, no hay niveles de acceso privado/público a nivel de módulo; todo lo global en un módulo se puede acceder desde fuera importándolo, aunque por convención se usa el prefijo "\_" en el nombre para indicar "interno, no usar externamente").

En resumen, **el *scope* determina la visibilidad de una variable**: las globales son accesibles en cualquier parte (lectura directa, y escritura con `global`), mientras que las locales solo dentro de su función. Comprender esto ayuda a evitar errores de referencia a variables no definidas en cierto contexto, y a estructurar mejor el código.

### Reasignación y eliminación de variables

**Reasignación:** Reasignar una variable significa darle un nuevo valor, usando nuevamente el operador `=` con otro dato. En Python la reasignación es directa: simplemente `mi_var = nuevo_valor`. Como ya discutimos, esto hará que la variable ahora apunte a un objeto distinto (a menos que el nuevo valor sea el mismo objeto que antes, caso en el que conceptualmente no cambia nada). No hay restricción de tipos en la reasignación: puedes hacer `contador = 10` y luego `contador = "diez"` si quisieras, aunque lógicamente cambiar el tipo de una variable a mitad del programa puede ser fuente de errores si no se documenta bien. La reasignación es la base de actualizar contadores, acumuladores y en general cualquier variable cuyo valor deba cambiar durante la ejecución. Por ejemplo:

```python
x = 0
x = x + 1   # ahora x vale 1 (tomó el viejo valor 0, sumó 1, y reasignó)
x = x + 1   # ahora x vale 2
print(x)    # imprime 2
```

Python evalúa la parte derecha `x + 1` usando el valor antiguo de x, luego asigna el resultado a x mismo. Esto es perfectamente válido (x aparece en ambos lados) y muy común. Existe también operadores compuestos como `x += 1` que hacen lo mismo de forma más concisa.

**Eliminación de variables:** En Python es posible *eliminar* una variable, es decir, remover su nombre del entorno actual, utilizando la instrucción `del`. La sintaxis es `del nombre_de_variable`. Esto rompe la asociación entre el nombre y el objeto al que refería. Tras un `del`, tratar de usar ese nombre de variable dará un error `NameError` (salvo que exista una variable global u de otro scope con el mismo nombre, en cuyo caso podría referirse a esa). Por ejemplo:

```python
x = 10
print(x)    # salida: 10
del x
# print(x)  # NameError: name 'x' is not defined, pues x fue eliminada
```



Cuando hacemos `del x`, Python elimina la entrada de `x` en la tabla de símbolos local (o global, según donde estemos). Si no había otras referencias al objeto 10, entonces ese objeto entero quedará sin referencias y el *garbage collector* lo liberará en algún momento, recuperando la memoria. Si había otras variables referenciando el mismo objeto, ese objeto no se borrará hasta que todas las referencias se eliminen. Es decir, `del` se enfoca en los nombres, no forzosamente en los objetos (aunque libera objetos indirectamente al quitar referencias). Cabe mencionar que `del` también se usa para borrar elementos de estructuras, e.g. `del lista[2]` borra el elemento en índice 2 de una lista, o `del dict['clave']` borra una entrada de diccionario. En todos los casos es una operación destructiva.

En la práctica, no es muy común eliminar variables manualmente en scripts pequeños – basta con dejarlas de usar y Python las limpiará cuando salga del scope. Sin embargo, en sesiones interactivivas o notebooks a veces se usa `del` para liberar nombres que ya no se necesitan (especialmente si apuntaban a objetos grandes en memoria). También es útil en ciertos algoritmos para remover variables globales temporales y evitar reuso accidental.

**Ejemplo de uso de `del`:**

```python
a = 5
b = a        # b referencia el mismo objeto que a (el entero 5)
del a
# Ahora 'a' ya no existe, pero 'b' sigue existiendo y vale 5
print(b)     # salida: 5
```

En este ejemplo, eliminar `a` no afecta al objeto `5` porque `b` aún lo referencia, así que el entero 5 sigue vivo y `b` lo puede usar. Si elimináramos también `b` con `del b`, entonces el entero 5 quedaría huérfano y Python podría recuperar esa memoria eventualmente.

**Precaución:** No se puede usar `del` sobre variables que no existen (eso produce un NameError inmediato). Tampoco se puede eliminar nombres especiales o builtins por seguridad (por ejemplo, no puedes hacer `del __name__` dentro de un módulo). Y si se hace `del x` dentro de una función, solo elimina la variable local x de esa función en ese momento.

**Resumiendo:** La reasignación nos permite cambiar el valor asociado a un nombre de variable durante la ejecución. La eliminación (`del`) nos permite *olvidar* una variable antes de salir de su scope, lo que remove su nombre del espacio de nombres actual. En muchos casos no se necesita usar `del` explícitamente, pero es bueno saber que existe. En proyectos grandes, gestionar la vida de las variables (scope, creación y destrucción) es importante para el manejo de memoria y claridad del código.

## 5. Comparación breve con otros lenguajes (C, Java) respecto a variables

Es instructivo comparar cómo funcionan las variables en Python frente a lenguajes como **C** o **Java**, ya que muchos conceptos se comparten pero hay diferencias clave:

* **Declaración y tipado estático vs dinámico:** En C y Java, las variables **deben declararse con un tipo específico** antes de usarse, y ese tipo es estático (no puede cambiar). Por ejemplo, en Java podemos declarar `int contador = 0;` y a partir de ahí `contador` *siempre* será un entero (podemos cambiar su valor, pero solo por otros enteros). Si intentáramos asignarle una cadena, el código ni siquiera compilaría. En Python, como vimos, no declaramos el tipo y la variable puede recibir distintos tipos a lo largo del tiempo. Esta diferencia es fundamental: **Python es dinámicamente tipado, C/Java son estáticamente tipados**. Una consecuencia es que en C/Java muchas incompatibilidades de tipos se detectan en compilación, mientras que en Python pueden aparecer en ejecución si ocurre (pero Python ofrece más flexibilidad de codificación rápida). También implica que en C/Java uno piensa en términos de "reservar X bytes para un int" al declarar la variable; en Python uno piensa en "tengo un nombre que apunta a un objeto en el heap".

* **Sintaxis de declaración:** Relacionado con lo anterior, la sintaxis difiere. En C se escribe `<tipo> <nombre>;` para declarar (y opcionalmente asignar) una variable. En Java es similar, con la posibilidad de inicializadores y con tipos de referencia para objetos. En Python simplemente `nombre = valor`. Por ejemplo:

  * En C: `float temperatura; temperatura = 23.5;` – hay que indicar que será un flotante.
  * En Python: `temperatura = 23.5` – Python automáticamente sabe que 23.5 es un float en ese momento, no se escribe aparte.

  Además, en C es un error usar una variable no inicializada (no asignada) porque contendrá basura de memoria; en Java es un error compilar si una local podría usarse sin asignar; en Python es un error usar una variable que nunca fue asignada (NameError). Eso es parecido en el sentido de evitar variables sin inicializar, solo que la comprobación ocurre en distinto momento.

* **Uso de variables / Modelo de datos:** En Python todo es objeto y las variables son referencias a objetos. En Java también (salvo para tipos primitivos que se almacenan directamente en la variable), aunque Java distingue entre tipos primitivos (int, double, etc., que funcionan más como en C) y tipos por referencia (objetos). En C, una variable de tipo básico es esencialmente una posición fija en memoria que contiene el valor (por valor), mientras que en Python una variable es una entrada en un *diccionario de nombres* apuntando a un objeto en el heap. Esto hace que, por ejemplo, la semántica de pasar variables a funciones difiera: en C pasas por valor (o por puntero si quieres referencia), en Python siempre se pasan las referencias (los objetos en sí no se copian automáticamente al pasar a funciones). En Java, pasar objetos es similar a Python (referencias), pasar primitivos es por valor (copia).

* **Mutabilidad y constancia:** C tiene el concepto de variables *const* (que no pueden modificarse una vez asignadas), y Java tiene `final` para algo similar (o la inmutabilidad de ciertos objetos, como `String` en Java que es inmutable). Python no tiene palabras clave para constantes, pero por convención se usan nombres en mayúsculas. A nivel de mutabilidad de objetos, Python y Java comparten la idea de algunos objetos mutables (Java: `StringBuilder` mutable vs `String` inmutable, por ejemplo), y C realmente no tiene esa distinción a nivel de lenguaje (cualquier bloque de memoria puede modificarse a menos que se use const). Para un programador inicial, esto se resume en que *en Python, igual que en Java, algunas estructuras (listas, arreglos en Java) cambian en sitio, otras no*.

* **Alcance:** C y Java definen alcance de variables por bloques `{ }`. Una variable declarada dentro de un bloque en C/Java no existe fuera de él. Python, como dijimos, solo tiene global y función (y clase) como delimitadores de scope, no los bloques como loops/if. También, Java tiene variables miembro (atributos de clase/instancia) con reglas de acceso, que Python maneja con atributos de objetos y convención (privadas con `_`). En C no hay atributos porque no hay clases, pero hay variables *estáticas* a nivel de archivo con alcance restringido, etc. Son detalles de cada lenguaje; Python opta por sencillez en ese sentido.

* **Gestión de memoria:** En C, el programador tiene control manual (puede usar punteros, reservar y liberar). En Java y Python hay **recolección de basura** automática. La diferencia es que Python es interpretado y maneja referencias de forma más dinámica (con conteo de referencias, etc.), mientras Java compila a bytecode y su garbage collector es diferente. Pero en ambos el programador no suele preocuparse por free() la memoria de una variable común. Un detalle: en C, uno puede tener variables locales que ocupan muy poca memoria y están en la pila (muy eficiente); en Python, incluso un simple entero es un objeto en el heap con cierta sobrecarga. Eso hace que Python sea usualmente más lento y consuma más memoria para ciertas tareas respecto a C, a cambio de la flexibilidad. En Java, los primitivos se comportan eficientemente en la stack, los objetos en heap con overhead similar a Python en algunos casos.

En general, **Python sacrifica algo de rendimiento a cambio de flexibilidad y simplicidad en el manejo de variables**. No es necesario especificar tipos ni gestionar memoria manualmente, lo cual acelera el desarrollo y reduce errores de gestión de memoria o de tipos, aunque esos errores se sustituyen por posibles excepciones en tiempo de ejecución si uno no controla los tipos lógicamente.

**Diferencia en un ejemplo simple:** Supongamos que queremos definir una variable para la edad de una persona e incrementarla en 1:

* En C:

  ```c
  int edad = 20;
  edad = edad + 1;
  printf("%d", edad);
  ```

  Aquí tuvimos que declarar `int`. Si intentáramos `edad = "veinte";` ni compila, tipos incompatibles.

* En Java:

  ```java
  int edad = 20;
  edad = edad + 1;
  System.out.println(edad);
  ```

  Similar a C en este caso. Además, está dentro de una clase/método, etc.

* En Python:

  ```python
  edad = 20
  edad = edad + 1
  print(edad)
  ```

  No declaramos tipo. Y podríamos en teoría luego hacer `edad = "veintiuno"` sin error de sintaxis (aunque semánticamente tendría otro significado).

Otra diferencia menor: en Python no usamos `;` al final de línea ni tipo de retorno en funciones, etc., lo cual hace el código más conciso. Pero eso es sintaxis general, no solo de variables.

**Conclusión de la comparación:** Python se destaca por su **tipado dinámico (no necesita declarar tipos) y fuerte**, y por tratar a las variables como referencias de alto nivel. C y Java requieren declaración de tipo (tipado estático) y por tanto las variables están más vinculadas a posiciones de memoria fijas o a tipos fijos. A la hora de programar, esto significa que con Python se puede prototipar más rápido, pero en C/Java el código puede ser más seguro respecto a tipos desde el comienzo. En aprendizaje inicial, muchos encuentran Python más amistoso por evitar complejidad de sintaxis de declaración, punteros, etc., pero es útil saber que bajo la alfombra las variables siempre se corresponden a algún trozo de memoria y a ciertas reglas de tipo, solo que Python las maneja automáticamente.

## 6. Buenas prácticas de uso y nomenclatura en Python (PEP 8)

En programación es fundamental adoptar **buenas prácticas** para nombrar y usar variables, de modo que el código sea legible y mantenible. Python cuenta con una guía oficial de estilo, la **PEP 8**, que establece convenciones para el código Python estándar, incluyendo cómo nombrar variables. A continuación resumimos las recomendaciones más importantes referentes a variables (y en general, nombres en el código):

* **Usa nombres descriptivos y claros:** El nombre de la variable debería indicar su propósito. Evita nombres crípticos o demasiado genéricos como `x` o `var1` si la variable tiene un significado específico. Es mejor `edad_usuario` que `x`, o `total_compras` que `t`. Un buen nombre de variable **facilita entender el código** sin necesidad de comentarios adicionales.

* **Convención *snake\_case* para variables y funciones:** En Python, por convención los nombres de variables **se escriben en minúsculas, y si tienen varias palabras se separan con guiones bajos** (underscores). A esto se le llama *snake\_case*. Por ejemplo: `contador`, `suma_total`, `nombre_cliente`. Esto mejora la legibilidad ya que `nombre_cliente` se lee mejor que `nombrecliente` o `NombreCliente`. Los nombres de funciones siguen la misma regla *snake\_case*.

* **Convención *PascalCase* (CamelCase) para nombres de clases:** Los nombres de clases en Python se escriben empezando cada palabra con mayúscula y sin separadores. Por ejemplo: `MiClase`, `ClienteVIP`, `JuegoDeMesa`. Esto las distingue visualmente de variables y funciones. (En otros lenguajes esto se llama CamelCase o PascalCase; en PEP8 se le suele decir CapWords convention).

* **Constantes en mayúsculas:** Si bien Python no tiene constantes verdaderas, se acostumbra escribir los nombres de variables **que deberían tratarse como constantes en MAYÚSCULAS completas**, separando palabras con \_ si es necesario. Por ejemplo: `MAX_INTENTOS = 5`, `PI = 3.1416`. Esto le indica a otros programadores (y a uno mismo) que ese valor no debería ser reasignado durante la ejecución. Aunque Python no lo impide, es un acuerdo común.

* **Evitar ciertos caracteres en nombres:** PEP 8 recomienda **no usar la letra *"l"* minúscula, *"O"* mayúscula, ni *"I"* mayúscula como nombres de variables de un solo caracter**, porque pueden confundirse con el número uno (`1`) o cero (`0`) según la fuente tipográfica. Por ejemplo, `l = 5` puede ser visualmente confuso; es preferible usar `L` minúscula o otro nombre breve si se necesita (aunque en general, es mejor usar nombres más expresivos que una sola letra, excepto para casos muy comunes como índices en bucles: `i, j, k` suelen ser aceptables para contadores).

* **Caracteres permitidos:** Los nombres de variables pueden contener letras (A-Z, a-z), dígitos (0-9) y el carácter underscore `_`. **No pueden contener espacios ni signos de puntuación**. Tampoco pueden empezar con un dígito. Es inválido algo como `1variable` o `nombre-apellido`. Si necesitas separar palabras, usa `_` como dijimos. Python es **sensible a mayúsculas/minúsculas** en los nombres, o sea, `edad` y `Edad` son variables distintas (pero por convención no deberías crear dos nombres que difieran solo en caso porque lleva a confusión).

* **No usar palabras reservadas:** Python tiene palabras clave reservadas (como `if`, `for`, `while`, `class`, `def`, etc.) que **no se pueden usar como nombres de variable**. Intentarlo produce un error de sintaxis. Por ejemplo, `class = 10` es inválido porque `class` es una palabra reservada. La lista completa de palabras reservadas incluye: `False`, `True`, `None`, `and`, `or`, `not`, `if`, `else`, `elif`, `while`, `for`, `break`, `continue`, `return`, `class`, `def`, `try`, `except`, `finally`, `import`, `from`, `as`, `pass`, `global`, `nonlocal`, `assert`, `yield`, `lambda`, entre otras. Un IDE o editor normalmente las resalta. Si necesitas usar un nombre parecido, puedes modificarlo (por ejemplo `class` no se puede, pero `clase` en español sí, aunque mejor usar inglés como vemos a continuación).

* **Prefiere nombres en inglés (y sin caracteres especiales):** Aunque Python 3 permite unicode en identificadores (podrías usar letras acentuadas, eñes, etc.), la PEP 8 sugiere usar caracteres ASCII para maximizar la compatibilidad. Además, en la práctica profesional el inglés es el idioma dominante en el código, porque equipos internacionales necesitan entenderlo. Así, es común aunque uno programe en español llamar a las variables `total_price` en vez de `precio_total` (pero esto no es una regla técnica, sino social). En un entorno académico en español, puedes usar español si todos lo entienden, pero ten en cuenta que si combinas con librerías de terceros u otros códigos, mantener el inglés evita mezclar idiomas. **Lo más importante es la consistencia:** no mezclar idiomas ni convenciones en los nombres dentro de un mismo proyecto.

* **Usar `_` inicial para "variables internas":** En Python no hay variables verdaderamente privadas, pero por convención un nombre que comienza con guión bajo `_` indica que es una variable interna o de uso privado en un módulo o clase. Por ejemplo, `_contador` sugiere "no tocar desde fuera". El intérprete en realidad aplica una ligera distinción en imports (al usar `from module import *` no importa nombres que empiezan con `_`), pero más allá de eso no impide su uso externo. Esta convención es útil para señalar la intención de encapsulamiento.

* **Constancia vs cambiabilidad:** Si una variable no debería cambiar una vez asignada (una constante lógica), nómbrala en mayúsculas como dijimos. En cambio, si es una variable de control que cambiará (ej: `i` en un bucle), un nombre corto está bien. No reutilices una misma variable para propósitos distintos en diferentes partes del código – es mejor crear otra con nombre diferente para evitar confusiones, incluso si técnicamente podrías reciclarla.

* **Formato y estilo general:** Mantén el código indentado correctamente (4 espacios por nivel en Python). Declara las variables lo más cerca posible de donde se usan (en Python, igual tienes que asignarlas antes de usar; en otros lenguajes a veces se declaran todas arriba, pero en Python suele ser al vuelo). Agrupa visualmente las asignaciones relacionadas. Por ejemplo, si configuras varias constantes globales, puedes ponerlas juntas al inicio. O si dentro de una función calculas varias sub-variables intermedias, tal vez secciones el código con líneas en blanco para claridad.

Un ejemplo aplicando varias convenciones:

```python
# Ejemplo de nomenclatura y uso adecuado
MAX_CONEXIONES = 5          # constante global en mayúsculas

def calcular_promedio(valores):
    total = sum(valores)    # 'total' descriptivo
    cantidad = len(valores) # 'cantidad' descriptivo
    promedio = total / cantidad if cantidad > 0 else 0
    return promedio

# Variables globales (evitar en lo posible, pero si existen:)
_conexion_actual = 0        # el guión bajo sugiere que es interna al módulo

def conectar():
    global _conexion_actual
    if _conexion_actual < MAX_CONEXIONES:
        _conexion_actual += 1
        print(f"Conexión número {_conexion_actual} establecida.")
    else:
        print("Límite de conexiones alcanzado.")
```

En este código, vemos constantes en mayúsculas, variables locales en minúscula, uso de nombres claros y `_` para indicar una variable interna global. También se usa un f-string en el print (que es preferible a concatenar con `+`, otra recomendación de estilo para manejar strings formateados, aunque eso ya es sobre sintaxis).

Resumiendo las convenciones principales conforme a PEP 8 y buenas prácticas generales:

* **snake\_case** para nombres de variables y funciones (minúsculas\_con\_guion\_bajo).
* **CamelCase** (CapWords) para clases y tipos abstractos.
* **MAYÚSCULAS\_CON\_GUIONES\_BAJO** para constantes que no deben cambiar.
* **Evitar nombres confusos** (como `l`, `O`, `I` solos).
* **Evitar caracteres especiales y espacios** (solo usar ASCII alfanumérico y `_`).
* **No usar palabras reservadas** para nombres.
* **Ser consistente**: si decides nombrar algo de cierta forma, mantén ese estilo en todo el código.
* **Prefijar con `_`** los nombres que son “privados” o de uso interno.
* **Legibilidad sobre ahorros mínimos:** es preferible un nombre largo pero claro (`tiempo_restante_segundos`) que uno corto y enigmático (`trs`), salvo en contextos muy acotados donde notación corta sea estándar (por ejemplo `i, j` en bucles anidados pequeños está aceptado).

Siguiendo estas prácticas, el código de Python se vuelve más fácil de leer y mantener para ti y otros colaboradores. PEP 8 enfatiza que “el código es leído mucho más a menudo de lo que es escrito”, por lo que invertir en buena nomenclatura y estilo es invertir en menos errores y menos tiempo de comprensión en el futuro.

## 7. Ejercicios prácticos (con soluciones en Python)

Finalmente, para afianzar estos conceptos, se proponen algunos **ejercicios prácticos** sencillos. Intente resolver cada uno razonando cuál es la mejor manera de usar variables, y luego compare con la solución proporcionada:

1. **Escribir un programa que almacene la cadena** `"¡Hola Mundo!"` **en una variable y luego muestre por pantalla el contenido de dicha variable.**

   ```python
   # Solución:
   mensaje = "¡Hola Mundo!"
   print(mensaje)
   ```

   *Explicación:* Aquí simplemente creamos la variable `mensaje` con el texto deseado y la imprimimos. Este ejercicio valida que sabemos asignar un string a una variable y usar `print` para ver su valor.

2. **Crear dos variables numéricas, asignarles dos números cualesquiera, y mostrar por pantalla el resultado de sumarlas, restarlas, multiplicarlas y dividir la primera por la segunda.**

   ```python
   # Solución:
   a = 12
   b = 5
   print("Suma:", a + b)             # 17
   print("Resta:", a - b)            # 7
   print("Producto:", a * b)         # 60
   print("División:", a / b)         # 2.4 (división de punto flotante)
   ```

   *Explicación:* Definimos `a` y `b` con valores de ejemplo (12 y 5). Luego realizamos las operaciones básicas usando estos valores. En Python, `a/b` produce un número de coma flotante (float), aunque los dos sean enteros.

3. **Escribir un programa que calcule el área y el perímetro de un círculo dado su radio almacenado en una variable.** Usa `PI = 3.1416` como constante para π. Muestra ambos resultados.

   ```python
   # Solución:
   PI = 3.1416
   radio = 3.0
   area = PI * (radio ** 2)               # fórmula: π * r^2
   perimetro = 2 * PI * radio             # fórmula: 2πr
   print("Área del círculo:", area)
   print("Perímetro (circunferencia):", perimetro)
   ```

   *Explicación:* Aquí usamos una constante `PI` en mayúsculas. La variable `radio` es un número (float). Calculamos el área y perímetro aplicando las fórmulas geométricas correspondientes. Observa el uso de `** 2` para elevar al cuadrado. Al final imprimimos los resultados. (En un programa real podríamos pedir el radio al usuario con `input`, pero aquí lo mantenemos fijo para centrarnos en las variables).

4. **Intercambiar los valores de dos variables.** Por ejemplo, si `x = 10` y `y = 20`, que al final del programa `x` valga 20 e `y` valga 10 (y esto funcione para *cualquier* valor inicial de `x` y `y`). Mostrar los valores antes y después del intercambio.

   ```python
   # Solución:
   x = 10
   y = 20
   print("Antes: x =", x, ", y =", y)

   # Método 1: usando variable temporal auxiliar
   temp = x
   x = y
   y = temp

   # Método 2 (Python): asignación múltiple en una línea
   # x, y = y, x   # (descomentar esta línea y comentar el método 1 para usar este método)

   print("Después: x =", x, ", y =", y)
   ```

   *Explicación:* Hay dos formas mostradas. El método 1 es el más "universal": usamos una variable temporal `temp` para guardar `x`, luego asignamos a `x` el valor de `y`, y finalmente ponemos en `y` lo que estaba en `temp` (que era el valor original de `x`). Esto logra el swap de valores. El método 2 aprovecha una característica de Python que permite hacer intercambio en una sola línea mediante tuplas: `x, y = y, x` hace simultáneamente ese intercambio sin necesidad de variable auxiliar. En ambos casos, imprimimos antes y después para verificar.

5. **Escribir un programa que le pregunte al usuario su nombre y su edad, y luego imprima **un saludo personalizado**.** Por ejemplo, si el usuario ingresa nombre "Ana" y edad "30", podría mostrar: `"Hola Ana, tienes 30 años."`

   ```python
   # Solución:
   nombre = input("¿Cómo te llamas? ")
   edad = input("¿Cuántos años tienes? ")
   print("Hola " + nombre + ", tienes " + edad + " años.")
   ```

   *Explicación:* Usamos `input()` para leer una cadena del usuario (primero el nombre, luego la edad). `input` siempre devuelve un string, por eso podemos concatenar directamente `edad` sin convertir (si quisiéramos tratarla como número para algún cálculo, usaríamos `int(edad)`, pero aquí solo la reenviamos). Luego construimos el mensaje de saludo concatenando cadenas y variables. Nótese el espacio después de "Hola " y antes de ", tienes", etc., para que la frase tenga espacios apropiados. También podríamos haber usado *f-strings* así: `print(f"Hola {nombre}, tienes {edad} años.")`, que quizás es más limpio, pero la solución dada es perfectamente válida para un nivel inicial.

Estos ejercicios cubren operaciones básicas con variables: asignación, entrada/salida, cálculos y manipulación de valores. Es recomendable que el estudiante pruebe modificar los valores y las expresiones para ver distintos resultados y así afianzar la comprensión del comportamiento de las variables en Python. También, se sugiere intentar escribir estos programas sin mirar la solución primero, y luego comparar para identificar mejoras o diferencias de estilo (por ejemplo, en el ejercicio 4, ¿habías pensado en la sintaxis `x, y = y, x` de Python? Es una feature interesante del lenguaje).

---
